package com.services.pricing_rules_service.mapper;

import com.services.pricing_rules_service.domain.entity.PricingRule;
import com.services.pricing_rules_service.dto.CreatePricingRuleRequest;
import com.services.pricing_rules_service.dto.PricingRuleResponse;
import com.services.pricing_rules_service.dto.UpdatePricingRuleRequest;
import org.mapstruct.*;

/**
 * MapStruct mapper for {@link PricingRule} entity and related DTOs.
 * 
 * <p>This mapper provides bidirectional transformations between:</p>
 * <ul>
 *   <li><strong>Entity → DTO</strong>: For API responses ({@link #toResponse(PricingRule)})</li>
 *   <li><strong>DTO → Entity</strong>: For creating new rules ({@link #toEntity(CreatePricingRuleRequest)})</li>
 *   <li><strong>DTO → Entity (partial)</strong>: For updating existing rules ({@link #updateRuleFromRequest(UpdatePricingRuleRequest, PricingRule)})</li>
 * </ul>
 * 
 * <p><strong>Null Handling:</strong></p>
 * <ul>
 *   <li>{@code NullValuePropertyMappingStrategy.IGNORE} - Null values in update DTOs are ignored (preserves existing entity values)</li>
 *   <li>{@code NullValueCheckStrategy.ALWAYS} - Explicit null checks before mapping</li>
 * </ul>
 * 
 * <p><strong>Component Model:</strong></p>
 * <ul>
 *   <li>{@code spring} - MapStruct generates a Spring {@code @Component} bean</li>
 *   <li>Can be injected via {@code @Autowired} or constructor injection</li>
 * </ul>
 * 
 * <p><strong>Generated Fields:</strong></p>
 * <ul>
 *   <li>{@code effectivePeriod} - Ignored in all mappings (database-generated column)</li>
 *   <li>Audit fields ({@code createdDate}, {@code lastModifiedDate}, etc.) - Managed by JPA Auditing, not mapped from DTOs</li>
 * </ul>
 * 
 * <p><strong>Usage Example:</strong></p>
 * <pre>{@code
 * @Service
 * public class PricingRuleService {
 *     private final PricingRuleMapper mapper;
 *     
 *     // Constructor injection
 *     public PricingRuleService(PricingRuleMapper mapper) {
 *         this.mapper = mapper;
 *     }
 *     
 *     public PricingRuleResponse createRule(CreatePricingRuleRequest request) {
 *         PricingRule entity = mapper.toEntity(request);
 *         PricingRule saved = repository.save(entity);
 *         return mapper.toResponse(saved);
 *     }
 * }
 * }</pre>
 * 
 * @author Car Sharing Team
 * @version 1.0
 * @since 2025-11-06
 * @see PricingRule
 * @see CreatePricingRuleRequest
 * @see UpdatePricingRuleRequest
 * @see PricingRuleResponse
 */
@Mapper(
    componentModel = "spring",
    nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE,
    nullValueCheckStrategy = NullValueCheckStrategy.ALWAYS
)
public interface PricingRuleMapper {

    /**
     * Converts a {@link PricingRule} entity to a {@link PricingRuleResponse} DTO.
     * 
     * <p>This method is used for all read operations (GET endpoints). It includes:</p>
     * <ul>
     *   <li>All business fields (unit, category, price, durations, etc.)</li>
     *   <li>Audit metadata (createdDate, createdBy, lastModifiedDate, lastModifiedBy)</li>
     * </ul>
     * 
     * <p><strong>Note:</strong> The {@code effectivePeriod} field is excluded (database-only representation).</p>
     * 
     * @param pricingRule The entity to convert
     * @return DTO representation for API response, or {@code null} if input is {@code null}
     */
    @Mapping(target = "id", source = "id")
    @Mapping(target = "unit", source = "unit")
    @Mapping(target = "vehicleCategory", source = "vehicleCategory")
    @Mapping(target = "pricePerUnit", source = "pricePerUnit")
    @Mapping(target = "minDuration", source = "minDuration")
    @Mapping(target = "maxDuration", source = "maxDuration")
    @Mapping(target = "cancellationWindow", source = "cancellationWindow")
    @Mapping(target = "lateReturnPenaltyPercent", source = "lateReturnPenaltyPercent")
    @Mapping(target = "effectiveFrom", source = "effectiveFrom")
    @Mapping(target = "effectiveTo", source = "effectiveTo")
    @Mapping(target = "active", source = "active")
    @Mapping(target = "createdDate", source = "createdDate")
    @Mapping(target = "lastModifiedDate", source = "lastModifiedDate")
    @Mapping(target = "createdBy", source = "createdBy")
    @Mapping(target = "lastModifiedBy", source = "lastModifiedBy")
    PricingRuleResponse toResponse(PricingRule pricingRule);

    /**
     * Converts a {@link CreatePricingRuleRequest} DTO to a new {@link PricingRule} entity.
     * 
     * <p>This method is used for POST /v1/pricing/rules (create operation). It:</p>
     * <ul>
     *   <li>Maps all business fields from request DTO</li>
     *   <li>Leaves {@code id} as {@code null} (auto-generated by database)</li>
     *   <li>Leaves audit fields as {@code null} (populated by JPA Auditing on persist)</li>
     *   <li>Ignores {@code effectivePeriod} (database-generated column)</li>
     * </ul>
     * 
     * @param request The request DTO containing new rule data
     * @return New entity instance ready for persistence, or {@code null} if input is {@code null}
     */
    @Mapping(target = "id", ignore = true) // Auto-generated
    @Mapping(target = "effectivePeriod", ignore = true) // Database-generated
    @Mapping(target = "createdDate", ignore = true) // JPA Auditing
    @Mapping(target = "lastModifiedDate", ignore = true) // JPA Auditing
    @Mapping(target = "createdBy", ignore = true) // JPA Auditing
    @Mapping(target = "lastModifiedBy", ignore = true) // JPA Auditing
    PricingRule toEntity(CreatePricingRuleRequest request);

    /**
     * Updates an existing {@link PricingRule} entity with values from {@link UpdatePricingRuleRequest}.
     * 
     * <p>This method supports <strong>partial updates</strong> (PATCH semantics):</p>
     * <ul>
     *   <li>Only non-null fields from {@code request} are applied to {@code target}</li>
     *   <li>Null fields in {@code request} are ignored (preserves existing entity values)</li>
     *   <li>The {@code @MappingTarget} annotation modifies the target entity in-place</li>
     * </ul>
     * 
     * <p><strong>Immutable Fields:</strong></p>
     * <ul>
     *   <li>{@code id} - Never changed (URL path parameter)</li>
     *   <li>{@code effectivePeriod} - Database-generated, cannot be manually set</li>
     *   <li>{@code createdDate}, {@code createdBy} - Audit trail, never modified</li>
     *   <li>{@code lastModifiedDate}, {@code lastModifiedBy} - Updated by JPA Auditing trigger</li>
     * </ul>
     * 
     * <p><strong>Usage Example:</strong></p>
     * <pre>{@code
     * // Only update price, leave other fields unchanged
     * UpdatePricingRuleRequest request = UpdatePricingRuleRequest.builder()
     *     .pricePerUnit(new BigDecimal("15.00"))
     *     .build();
     * 
     * PricingRule existing = repository.findById(ruleId).orElseThrow();
     * mapper.updateRuleFromRequest(request, existing);
     * repository.save(existing); // Triggers JPA Auditing
     * }</pre>
     * 
     * @param request The update request DTO (may contain null fields)
     * @param target The existing entity to update (modified in-place)
     */
    @Mapping(target = "id", ignore = true) // Immutable
    @Mapping(target = "effectivePeriod", ignore = true) // Database-generated
    @Mapping(target = "createdDate", ignore = true) // Immutable audit field
    @Mapping(target = "createdBy", ignore = true) // Immutable audit field
    @Mapping(target = "lastModifiedDate", ignore = true) // JPA Auditing
    @Mapping(target = "lastModifiedBy", ignore = true) // JPA Auditing
    void updateRuleFromRequest(UpdatePricingRuleRequest request, @MappingTarget PricingRule target);
}
