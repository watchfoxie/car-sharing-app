-- Flyway migration for Rental Service schema initialization
-- Version: V1
-- Description: Initial schema creation for rental.cars_rental_history with FSM, EXCLUDE constraint, and idempotency
-- Author: Car Sharing Team
-- Date: 2025-01-09

-- =====================================================
-- 0) Prerequisites and Extensions
-- =====================================================

-- Ensure btree_gist extension is installed (required for EXCLUDE constraint with rental_period && operator)
CREATE EXTENSION IF NOT EXISTS btree_gist;

-- Ensure citext extension is installed (for case-insensitive text)
CREATE EXTENSION IF NOT EXISTS citext;

-- =====================================================
-- 1) Schema Creation
-- =====================================================

CREATE SCHEMA IF NOT EXISTS rental;

-- =====================================================
-- 2) Enum Types (idempotent creation)
-- =====================================================

-- Rental status FSM enum
DO $$ BEGIN
  PERFORM 1 FROM pg_type WHERE typname = 'rental_status';
  IF NOT FOUND THEN
    CREATE TYPE rental_status AS ENUM (
      'PENDING',           -- Initial state, awaiting validation
      'CONFIRMED',         -- Validated and confirmed, vehicle reserved
      'PICKED_UP',         -- Customer has taken possession, rental started
      'RETURNED',          -- Customer has returned vehicle, awaiting approval
      'RETURN_APPROVED',   -- Operator approved return, rental completed
      'CANCELLED'          -- Rental cancelled (only before PICKED_UP)
    );
  END IF;
END $$;

-- =====================================================
-- 3) Audit Trigger Function (shared across schemas)
-- =====================================================

-- Create audit trigger function if not exists
CREATE OR REPLACE FUNCTION public.set_audit_fields() RETURNS trigger AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    NEW.created_date := COALESCE(NEW.created_date, now());
    NEW.created_by   := COALESCE(NEW.created_by, current_setting('app.current_account_id', true), 'system');
  END IF;
  NEW.last_modified_date := now();
  NEW.last_modified_by   := COALESCE(current_setting('app.current_account_id', true), NEW.last_modified_by, NEW.created_by, 'system');
  RETURN NEW;
END
$$ LANGUAGE plpgsql;

-- =====================================================
-- 3b) Immutable helper for rental period generation
-- =====================================================

-- Generated columns require immutable expressions; wrap the range builder
CREATE OR REPLACE FUNCTION rental.build_rental_period(
  pickup timestamptz,
  dropoff timestamptz
) RETURNS tstzrange
LANGUAGE sql
IMMUTABLE
AS $$
  SELECT CASE
    WHEN pickup IS NULL THEN NULL
    WHEN dropoff IS NULL THEN tstzrange(pickup, pickup + INTERVAL '100 years', '[)')
    WHEN dropoff >= pickup THEN tstzrange(pickup, dropoff, '[)')
    ELSE NULL
  END;
$$;

-- =====================================================
-- 4) Main Table: rental.cars_rental_history
-- =====================================================

CREATE TABLE IF NOT EXISTS rental.cars_rental_history (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  -- Foreign keys
  renter_id VARCHAR(255) NOT NULL,  -- References identity.accounts(id) ON DELETE RESTRICT
  cars_id BIGINT NOT NULL,          -- References car.cars(id) ON DELETE CASCADE

  -- Rental period fields
  pickup_datetime TIMESTAMPTZ NOT NULL,
  return_datetime TIMESTAMPTZ,      -- NULL for open-ended rentals

  -- Generated column for EXCLUDE constraint (TSTZRANGE: [pickup, return) with upper bound defaulting to 100 years)
  rental_period TSTZRANGE GENERATED ALWAYS AS (
    rental.build_rental_period(pickup_datetime, return_datetime)
  ) STORED,

  -- Location fields
  pickup_location VARCHAR(255),
  return_location VARCHAR(255),

  -- FSM status
  status rental_status NOT NULL DEFAULT 'PENDING',

  -- Cost fields
  estimated_cost NUMERIC(10,2),     -- Calculated at booking time
  final_cost NUMERIC(10,2),         -- Calculated at return approval

  -- Idempotency key for duplicate prevention
  idempotency_key VARCHAR(64),

  -- Audit fields (managed by JPA auditing)
  created_date TIMESTAMPTZ NOT NULL DEFAULT now(),
  last_modified_date TIMESTAMPTZ,
  created_by VARCHAR(255) NOT NULL DEFAULT 'system',
  last_modified_by VARCHAR(255),

  -- =====================================================
  -- CHECK Constraints
  -- =====================================================

  -- Return datetime must be >= pickup datetime
  CONSTRAINT chk_rental_return_after_pickup
    CHECK (return_datetime IS NULL OR return_datetime >= pickup_datetime),

  -- RETURNED/RETURN_APPROVED states require return_datetime
  CONSTRAINT chk_rental_return_datetime_required
    CHECK (
      (status IN ('RETURNED', 'RETURN_APPROVED') AND return_datetime IS NOT NULL)
      OR (status NOT IN ('RETURNED', 'RETURN_APPROVED'))
    ),

  -- =====================================================
  -- EXCLUDE Constraint (prevents overlapping active rentals)
  -- =====================================================

  -- Only CONFIRMED and PICKED_UP rentals block availability
  -- Uses GiST index on (cars_id, rental_period) with && (overlap) operator
  CONSTRAINT ex_cars_rental_no_overlap
    EXCLUDE USING gist (
      cars_id       WITH =,
      rental_period WITH &&
    ) WHERE (status IN ('CONFIRMED', 'PICKED_UP'))
);

-- =====================================================
-- 5) Indexes
-- =====================================================

-- Unique index on (renter_id, idempotency_key) for idempotent rental creation
CREATE UNIQUE INDEX IF NOT EXISTS uq_rental_idem 
  ON rental.cars_rental_history(renter_id, idempotency_key) 
  WHERE idempotency_key IS NOT NULL;

-- Index on cars_id for quick lookup by car
CREATE INDEX IF NOT EXISTS idx_history_cars_id 
  ON rental.cars_rental_history(cars_id);

-- Index on renter_id for quick lookup by customer
CREATE INDEX IF NOT EXISTS idx_history_renter_id 
  ON rental.cars_rental_history(renter_id);

-- Index on pickup_datetime for temporal queries
CREATE INDEX IF NOT EXISTS idx_history_pickup_datetime 
  ON rental.cars_rental_history(pickup_datetime);

-- Partial index for active rentals by car (used in availability checks)
CREATE INDEX IF NOT EXISTS idx_history_active_by_car 
  ON rental.cars_rental_history(cars_id) 
  WHERE status IN ('CONFIRMED', 'PICKED_UP');

-- GiST index on rental_period for efficient overlap queries
CREATE INDEX IF NOT EXISTS idx_history_period_active_gist 
  ON rental.cars_rental_history USING GIST (rental_period) 
  WHERE status IN ('CONFIRMED', 'PICKED_UP');

-- Index on status for FSM queries
CREATE INDEX IF NOT EXISTS idx_history_status 
  ON rental.cars_rental_history(status);

-- Composite index for operator queries (cars_id, status, pickup_datetime)
CREATE INDEX IF NOT EXISTS idx_history_car_status_pickup 
  ON rental.cars_rental_history(cars_id, status, pickup_datetime DESC);

-- =====================================================
-- 6) Audit Trigger
-- =====================================================

DROP TRIGGER IF EXISTS trg_rental_audit ON rental.cars_rental_history;
CREATE TRIGGER trg_rental_audit
BEFORE INSERT OR UPDATE ON rental.cars_rental_history
FOR EACH ROW EXECUTE FUNCTION public.set_audit_fields();

-- =====================================================
-- 7) Outbox Table (Event Sourcing Pattern)
-- =====================================================

CREATE TABLE IF NOT EXISTS rental.outbox_event (
  id UUID PRIMARY KEY,
  aggregate_type VARCHAR(100) NOT NULL,  -- e.g., 'Rental'
  aggregate_id VARCHAR(100) NOT NULL,    -- e.g., rental.id
  payload JSONB NOT NULL,                -- Event data
  headers JSONB,                         -- Metadata (correlation_id, etc.)
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  published_at TIMESTAMPTZ,              -- NULL until published
  status VARCHAR(20) NOT NULL DEFAULT 'NEW',  -- NEW | PUBLISHED | FAILED

  CONSTRAINT chk_rental_outbox_status CHECK (status IN ('NEW', 'PUBLISHED', 'FAILED'))
);

-- Indexes for outbox polling
CREATE INDEX IF NOT EXISTS idx_rental_outbox_status_created 
  ON rental.outbox_event(status, created_at);

CREATE INDEX IF NOT EXISTS idx_rental_outbox_new 
  ON rental.outbox_event(status) 
  WHERE status = 'NEW';

-- =====================================================
-- 8) Service Role and Permissions
-- =====================================================

-- Create role if not exists
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'rental_service') THEN
    CREATE ROLE rental_service NOLOGIN;
  END IF;
END $$;

-- Grant schema usage
GRANT USAGE ON SCHEMA rental TO rental_service;

-- Grant table permissions
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA rental TO rental_service;

-- Grant sequence permissions (for IDENTITY columns)
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA rental TO rental_service;

-- =====================================================
-- 9) Comments (Documentation)
-- =====================================================

COMMENT ON SCHEMA rental IS 'Rental Service schema: manages car rental lifecycle with FSM and conflict prevention';

COMMENT ON TABLE rental.cars_rental_history IS $$
Stores complete rental history with FSM (PENDING → CONFIRMED → PICKED_UP → RETURNED → RETURN_APPROVED).
EXCLUDE constraint prevents overlapping active rentals on same car.
$$;

COMMENT ON COLUMN rental.cars_rental_history.rental_period IS $$
Generated TSTZRANGE column: [pickup_datetime, return_datetime).
Upper bound defaults to 100 years for open-ended rentals. Used by EXCLUDE constraint.
$$;

COMMENT ON COLUMN rental.cars_rental_history.idempotency_key IS $$
Idempotency key for duplicate request prevention. Unique per (renter_id, idempotency_key).
$$;

COMMENT ON COLUMN rental.cars_rental_history.status IS $$
FSM state: PENDING → CONFIRMED → PICKED_UP → RETURNED → RETURN_APPROVED (or CANCELLED before PICKED_UP)
$$;

COMMENT ON CONSTRAINT ex_cars_rental_no_overlap ON rental.cars_rental_history IS $$
Prevents overlapping active rentals (CONFIRMED, PICKED_UP) on same car using GiST && operator on rental_period
$$;

DO $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM pg_indexes
    WHERE schemaname = 'rental'
      AND indexname = 'uq_rental_idem'
  ) THEN
    EXECUTE 'COMMENT ON INDEX rental.uq_rental_idem IS ''Ensures idempotent rental creation: (renter_id, idempotency_key) uniqueness''';
  END IF;
END $$;

-- =====================================================
-- End of V1__init.sql
-- =====================================================
